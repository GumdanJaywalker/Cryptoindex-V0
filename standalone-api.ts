#!/usr/bin/env node

/**
 * HOOATS Standalone API Server
 * 
 * Ïã§Ï†ú HOOATS ÏãúÏä§ÌÖúÏùÑ ÌÖåÏä§Ìä∏ÌïòÍ∏∞ ÏúÑÌïú ÎèÖÎ¶Ω API ÏÑúÎ≤Ñ
 * Next.js ÎπåÎìú Î¨∏Ï†úÎ•º Ïö∞ÌöåÌïòÏó¨ Ïã§Ï†ú lib Î™®ÎìàÎì§ÏùÑ ÏßÅÏ†ë ÏÇ¨Ïö©
 * 
 * Created: 2025-08-19
 */

const express = require('express');
const cors = require('cors');
const path = require('path');

// Express Ïï± Ï¥àÍ∏∞Ìôî
const app = express();
const PORT = process.env.PORT || 3000;

// Middleware ÏÑ§Ï†ï
app.use(cors());
app.use(express.json());

// Î°úÍπÖ ÎØ∏Îì§Ïõ®Ïñ¥
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);
  });
  
  next();
});

// Ïã§Ï†ú HOOATS Î™®ÎìàÎì§ÏùÑ ÎèôÏ†ÅÏúºÎ°ú import
let HybridSmartRouterV2, ParallelMatchingEngine, UltraPerformanceOrderbook, AsyncDBWriter;
let extractPrivyAuthFromRequest;

/**
 * Í∞úÎ∞úÏö© Ïù∏Ï¶ù ÎØ∏Îì§Ïõ®Ïñ¥ (Bearer dev-token)
 */
function devAuth(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Authorization header required' });
  }

  const token = authHeader.substring(7);
  
  if (token === 'dev-token') {
    // Í∞úÎ∞úÏö© ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÏÑ§Ï†ï
    req.user = {
      id: 'dev-user-123',
      email: 'dev@test.com'
    };
    return next();
  }

  return res.status(401).json({ error: 'Invalid token' });
}

/**
 * Ïã§Ï†ú Î™®ÎìàÎì§ÏùÑ ÎèôÏ†ÅÏúºÎ°ú Î°úÎìú
 */
async function loadHOOATSModules() {
  try {
    console.log('üì¶ Loading HOOATS modules...');

    // TypeScript Î™®ÎìàÎì§ÏùÑ requireÎ°ú Î°úÎìú
    const SmartRouterModule = require('./lib/trading/smart-router-v2');
    HybridSmartRouterV2 = SmartRouterModule.HybridSmartRouterV2;
    
    const ParallelMatchingModule = require('./lib/orderbook/parallel-matching-engine');
    ParallelMatchingEngine = ParallelMatchingModule.ParallelMatchingEngine;
    
    const UltraOrderbookModule = require('./lib/orderbook/ultra-performance-orderbook');
    UltraPerformanceOrderbook = UltraOrderbookModule.UltraPerformanceOrderbook;
    
    const AsyncDBModule = require('./lib/utils/async-db-writer');
    AsyncDBWriter = AsyncDBModule.AsyncDBWriter;

    const AuthModule = require('./lib/middleware/privy-auth');
    extractPrivyAuthFromRequest = AuthModule.extractPrivyAuthFromRequest;

    console.log('‚úÖ HOOATS modules loaded successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to load HOOATS modules:', error);
    throw error;
  }
}

// =============================================================================
// API ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï†ïÏùò (Ïã§Ï†ú Next.js API ÎùºÏö∞Ìä∏ÏôÄ ÎèôÏùº)
// =============================================================================

/**
 * GET /api/health - Ìó¨Ïä§Ï≤¥ÌÅ¨
 */
app.get('/api/health', async (req, res) => {
  try {
    // Ïã§Ï†ú health route Î°úÏßÅ Íµ¨ÌòÑ
    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      services: {}
    };

    // Redis Ïó∞Í≤∞ ÌôïÏù∏ (ParallelMatchingEngine ÌÜµÌï¥)
    try {
      const matchingEngine = ParallelMatchingEngine.getInstance();
      const metrics = matchingEngine.getMetrics();
      health.services.redis = { 
        status: 'connected', 
        queueUtilization: metrics.queueUtilization || 0
      };
    } catch (error) {
      health.services.redis = { status: 'disconnected', error: error.message };
      health.status = 'unhealthy';
    }

    // UltraPerformanceOrderbook ÏÉÅÌÉú ÌôïÏù∏
    try {
      const ultraOrderbook = UltraPerformanceOrderbook.getInstance();
      const metrics = ultraOrderbook.getMetrics();
      health.services.orderbook = { 
        status: 'active', 
        tps: metrics.tps || 0,
        latency_p50: metrics.latency?.p50 || 0
      };
    } catch (error) {
      health.services.orderbook = { status: 'error', error: error.message };
      health.status = 'unhealthy';
    }

    const statusCode = health.status === 'healthy' ? 200 : 503;
    res.status(statusCode).json(health);

  } catch (error) {
    console.error('Health check error:', error);
    res.status(503).json({
      status: 'error',
      error: error.message
    });
  }
});

/**
 * GET /api/redis/status - Redis ÏÉÅÌÉú ÌôïÏù∏
 */
app.get('/api/redis/status', devAuth, async (req, res) => {
  try {
    const matchingEngine = ParallelMatchingEngine.getInstance();
    const metrics = matchingEngine.getMetrics();
    
    res.json({
      connected: true,
      mode: 'standalone',
      metrics: metrics,
      queueUtilization: metrics.queueUtilization,
      shardCount: metrics.shards?.length || 0
    });
  } catch (error) {
    res.status(500).json({
      connected: false,
      error: error.message
    });
  }
});

/**
 * POST /api/trading/v2/orders - V2 ÌïòÏù¥Î∏åÎ¶¨Îìú Ï£ºÎ¨∏ Ï≤òÎ¶¨ (Ïã§Ï†ú Íµ¨ÌòÑ)
 */
app.post('/api/trading/v2/orders', devAuth, async (req, res) => {
  try {
    const user = req.user;
    const body = req.body;

    // ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù (Ïã§Ï†ú Next.js APIÏôÄ ÎèôÏùº)
    const { pair, type, side, amount, price } = body;

    if (!pair || !type || !side || !amount) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields'
      });
    }

    if (type === 'limit' && !price) {
      return res.status(400).json({
        success: false,
        error: 'Price is required for limit orders'
      });
    }

    console.log('üöÄ V2 ORDER PROCESSING:', { 
      pair: pair || 'HYPERINDEX-USDC', 
      type, 
      side, 
      amount, 
      price 
    });

    // Ïã§Ï†ú HybridSmartRouterV2 ÏÇ¨Ïö©
    const smartRouterV2 = HybridSmartRouterV2.getInstance();
    
    // V2 Ï£ºÎ¨∏ Í∞ùÏ≤¥ ÏÉùÏÑ± - UUID ÏÉùÏÑ± (Ïã§Ï†ú Î°úÏßÅÍ≥º ÎèôÏùº)
    const orderId = require('crypto').randomUUID();
    const orderV2 = {
      id: orderId,
      userId: user.id,
      pair: pair || 'HYPERINDEX-USDC',
      side: side,
      type: type,
      amount: amount.toString(),
      price: price ? price.toString() : '0',
      remaining: amount.toString(),
      status: 'active',
      timestamp: Date.now()
    };

    // Ïã§Ï†ú V2 ÌïòÏù¥Î∏åÎ¶¨Îìú ÎùºÏö∞ÌåÖ Ïã§Ìñâ
    const routingResult = await smartRouterV2.processHybridOrder(orderV2);

    // Ïã§Ï†ú AsyncDBWriter ÏÇ¨Ïö©ÌïòÏó¨ PostgreSQL Ï†ÄÏû•
    const asyncDBWriter = AsyncDBWriter.getInstance();
    
    const filledAmount = parseFloat(routingResult.totalFilled);
    const status = filledAmount >= parseFloat(orderV2.amount) * 0.99 ? 'filled' : 'partial';
    
    // Ïã§Ï†ú DB ÌÅêÏóê Ï∂îÍ∞Ä (Í∏∞Ï°¥ Î°úÏßÅÍ≥º ÎèôÏùº)
    asyncDBWriter.queueOrderHistory({
      user_id: user.id,
      pair: orderV2.pair,
      side: orderV2.side,
      order_type: orderV2.type,
      price: orderV2.type === 'limit' ? parseFloat(orderV2.price) : 
             (routingResult.averagePrice ? parseFloat(routingResult.averagePrice) : null),
      amount: parseFloat(orderV2.amount),
      filled_amount: filledAmount,
      status: status,
      redis_order_id: orderV2.id
    });

    // Í±∞Îûò Ïù¥Î†•Îì§ÏùÑ ÌÅêÏóê Ï∂îÍ∞Ä (Ïã§Ï†ú Î°úÏßÅÍ≥º ÎèôÏùº)
    if (routingResult.fills && routingResult.fills.length > 0) {
      routingResult.fills.forEach((fill) => {
        asyncDBWriter.queueTradeHistory({
          id: require('crypto').randomUUID(),
          pair: orderV2.pair,
          buyer_order_id: orderV2.side === 'buy' ? orderV2.id : (fill.source === 'AMM' ? 'amm' : null),
          seller_order_id: orderV2.side === 'sell' ? orderV2.id : (fill.source === 'AMM' ? 'amm' : null),
          price: parseFloat(fill.price),
          amount: parseFloat(fill.amount),
          side: orderV2.side,
          source: fill.source || 'unknown',
          buyer_fee: 0,
          seller_fee: 0,
          price_impact: fill.priceImpact || null,
          amm_reserves_before: fill.ammReservesBefore || null,
          amm_reserves_after: fill.ammReservesAfter || null,
          redis_trade_id: fill.id || null
        });
      });
    }

    console.log('‚úÖ V2 ORDER COMPLETED:', {
      orderId: orderV2.id,
      totalFilled: routingResult.totalFilled,
      averagePrice: routingResult.averagePrice,
      executionStats: routingResult.executionStats
    });

    // ÏùëÎãµ Ìè¨Îß∑ (Ïã§Ï†ú Next.js APIÏôÄ ÎèôÏùº)
    return res.json({
      success: true,
      order: {
        id: orderV2.id,
        pair: orderV2.pair,
        side: orderV2.side,
        type: orderV2.type,
        amount: orderV2.amount,
        price: orderV2.price,
        status: status,
        timestamp: orderV2.timestamp
      },
      routing: routingResult,
      executionStats: routingResult.executionStats,
      fills: routingResult.fills,
      summary: {
        totalFilled: routingResult.totalFilled,
        averagePrice: routingResult.averagePrice,
        totalChunks: routingResult.executionStats.totalChunks,
        ammChunks: routingResult.executionStats.ammChunks,
        orderbookChunks: routingResult.executionStats.orderbookChunks,
        iterations: routingResult.executionStats.iterations
      }
    });

  } catch (error) {
    console.error('‚ùå V2 Order processing error:', error);
    
    let errorMessage = 'Internal server error';
    let statusCode = 500;

    if (error instanceof Error) {
      if (error.message.includes('Limit price crosses market price')) {
        errorMessage = error.message;
        statusCode = 400;
      } else if (error.message.includes('Authentication')) {
        errorMessage = 'Authentication failed';
        statusCode = 401;
      } else {
        errorMessage = error.message;
      }
    }

    return res.status(statusCode).json({
      success: false,
      error: errorMessage,
      details: process.env.NODE_ENV === 'development' ? error : undefined
    });
  }
});

/**
 * GET /api/trading/v1/orderbook - Ïã§Ï†ú Ïò§ÎçîÎ∂Å Ï°∞Ìöå
 */
app.get('/api/trading/v1/orderbook', async (req, res) => {
  try {
    const { searchParams } = new URL(req.url, `http://${req.headers.host}`);
    const pair = searchParams.get('pair') || 'HYPERINDEX-USDC';
    const depth = parseInt(searchParams.get('depth') || '20');

    // Ïã§Ï†ú ParallelMatchingEngine ÏÇ¨Ïö©
    const matchingEngine = ParallelMatchingEngine.getInstance();
    const orderbook = await matchingEngine.getOrderbook(pair, depth);

    // Ïä§ÌîÑÎ†àÎìú Í≥ÑÏÇ∞ (Ïã§Ï†ú Î°úÏßÅÍ≥º ÎèôÏùº)
    let spread = null;
    if (orderbook.bids.length > 0 && orderbook.asks.length > 0) {
      const bestBid = parseFloat(orderbook.bids[0].price);
      const bestAsk = parseFloat(orderbook.asks[0].price);
      const spreadValue = bestAsk - bestBid;
      const spreadPercent = (spreadValue / bestBid) * 100;
      
      spread = {
        absolute: spreadValue.toFixed(9),
        percent: spreadPercent.toFixed(4)
      };
    }

    return res.json({
      success: true,
      orderbook: {
        pair,
        bids: orderbook.bids,
        asks: orderbook.asks,
        spread,
        lastUpdate: Date.now()
      }
    });

  } catch (error) {
    console.error('Orderbook fetch error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

/**
 * GET /api/trading/v1/market - Ïã§Ï†ú ÏãúÏû• Îç∞Ïù¥ÌÑ∞
 */
app.get('/api/trading/v1/market', devAuth, async (req, res) => {
  try {
    const { searchParams } = new URL(req.url, `http://${req.headers.host}`);
    const pair = searchParams.get('pair') || 'HYPERINDEX-USDC';

    // Ïã§Ï†ú ParallelMatchingEngineÏùÑ ÌÜµÌï¥ ÏãúÏû• Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    const matchingEngine = ParallelMatchingEngine.getInstance();
    const marketData = await matchingEngine.getMarketData(pair);

    return res.json({
      success: true,
      market: marketData
    });

  } catch (error) {
    console.error('Market data fetch error:', error);
    return res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// =============================================================================
// ÏÑúÎ≤Ñ Ï¥àÍ∏∞Ìôî Î∞è ÏãúÏûë
// =============================================================================

async function initializeHOOATS() {
  console.log('üöÄ Initializing HOOATS Standalone API Server...');
  
  try {
    // Ïã§Ï†ú HOOATS Î™®ÎìàÎì§ Î°úÎìú
    await loadHOOATSModules();

    // Ïã§Ï†ú Ïù∏Ïä§ÌÑ¥Ïä§Îì§ Ï¥àÍ∏∞Ìôî
    console.log('üîß Initializing HOOATS services...');
    
    const smartRouter = HybridSmartRouterV2.getInstance();
    console.log('‚úÖ HybridSmartRouterV2 initialized');

    const matchingEngine = ParallelMatchingEngine.getInstance();
    console.log('‚úÖ ParallelMatchingEngine initialized');

    const ultraOrderbook = UltraPerformanceOrderbook.getInstance();
    console.log('‚úÖ UltraPerformanceOrderbook initialized');

    const asyncDBWriter = AsyncDBWriter.getInstance();
    console.log('‚úÖ AsyncDBWriter initialized');

    console.log('üéâ All HOOATS services initialized successfully');

  } catch (error) {
    console.error('üí• HOOATS initialization failed:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  }
}

// ÏÑúÎ≤Ñ ÏãúÏûë
async function startServer() {
  await initializeHOOATS();

  app.listen(PORT, '0.0.0.0', () => {
    console.log('');
    console.log('üöÄ HOOATS Standalone API Server is running!');
    console.log(`üìç Server URL: http://localhost:${PORT}`);
    console.log('');
    console.log('üìã Available endpoints:');
    console.log('   GET  /api/health');
    console.log('   GET  /api/redis/status (auth required)');
    console.log('   POST /api/trading/v2/orders (auth required)');
    console.log('   GET  /api/trading/v1/orderbook');
    console.log('   GET  /api/trading/v1/market (auth required)');
    console.log('');
    console.log('üîë Auth: Bearer dev-token');
    console.log('');
    console.log('üéØ Ready for HOOATS testing!');
    console.log('   Run: npm run test:simple');
    console.log('');
  });
}

// Ï¢ÖÎ£å Ï≤òÎ¶¨
process.on('SIGINT', async () => {
  console.log('\nüõë Shutting down HOOATS server...');
  console.log('‚úÖ Server shutdown complete');
  process.exit(0);
});

// ÏòàÏô∏ Ï≤òÎ¶¨
process.on('uncaughtException', (error) => {
  console.error('üí• Uncaught Exception:', error);
  console.error('Stack:', error.stack);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// ÏÑúÎ≤Ñ ÏãúÏûë
if (require.main === module) {
  startServer().catch((error) => {
    console.error('üí• Failed to start server:', error);
    console.error('Stack:', error.stack);
    process.exit(1);
  });
}

module.exports = app;